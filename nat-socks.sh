#!/usr/bin/env bash
# nat-socks.sh
# One-click deploy SOCKS5 proxy (no-auth) via gost on Debian/Ubuntu (NAT-friendly).
# - Interactive: only asks for SOCKS5 listen port
# - Installs deps (curl, wget, tar)
# - Downloads latest gost (go-gost/gost) for amd64/arm64
# - Sets up systemd service: nat-socks (auto start on boot)
# - IPv6 preferred *only when IPv6 egress is available* (auto-detected)
# - Prints final SOCKS5 URI with public IPv4 and IPv6 egress status

set -euo pipefail

RED=$'\033[31m'
GREEN=$'\033[32m'
YELLOW=$'\033[33m'
BLUE=$'\033[34m'
BOLD=$'\033[1m'
RESET=$'\033[0m'

log()  { echo "${BLUE}[INFO]${RESET} $*"; }
warn() { echo "${YELLOW}[WARN]${RESET} $*"; }
die()  { echo "${RED}[ERR ]${RESET} $*" >&2; exit 1; }

need_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    die "Please run as root: sudo bash $0"
  fi
}

command_exists() { command -v "$1" >/dev/null 2>&1; }

install_deps() {
  log "Installing dependencies (curl, wget, tar)..."
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y >/dev/null
  apt-get install -y curl wget tar ca-certificates >/dev/null
}

ask_port() {
  local p=""
  read -r -p "Enter SOCKS5 listen port (1-65535): " p
  [[ "$p" =~ ^[0-9]+$ ]] || die "Port must be a number."
  (( p >= 1 && p <= 65535 )) || die "Port out of range."
  SOCKS_PORT="$p"
}

detect_arch() {
  local m
  m="$(uname -m)"
  case "$m" in
    x86_64|amd64) GOST_ARCH="amd64" ;;
    aarch64|arm64) GOST_ARCH="arm64" ;;
    *) die "Unsupported architecture: $m (only amd64/arm64 supported)" ;;
  esac
  log "Detected arch: ${GOST_ARCH}"
}

github_api_get_latest_tag() {
  # Use GitHub API to avoid hardcoding versions.
  # tag_name like "v3.2.6"
  local api="https://api.github.com/repos/go-gost/gost/releases/latest"
  local tag
  tag="$(curl -fsSL --max-time 15 "$api" | sed -n 's/^[[:space:]]*"tag_name":[[:space:]]*"\([^"]\+\)".*/\1/p' | head -n1)"
  [[ -n "${tag:-}" ]] || die "Failed to fetch latest gost release tag from GitHub API."
  echo "$tag"
}

download_and_install_gost() {
  local tag ver url tmpdir tarball

  tag="$(github_api_get_latest_tag)"
  ver="${tag#v}"

  # Asset naming in go-gost/gost releases is like:
  # gost_3.2.6_linux_amd64.tar.gz / gost_3.2.6_linux_arm64.tar.gz
  tarball="gost_${ver}_linux_${GOST_ARCH}.tar.gz"
  url="https://github.com/go-gost/gost/releases/download/${tag}/${tarball}"

  log "Latest gost: ${tag}"
  log "Downloading: ${url}"

  tmpdir="$(mktemp -d)"
  trap 'rm -rf "$tmpdir"' EXIT

  # Try curl first, fallback to wget
  if command_exists curl; then
    curl -fL --retry 3 --retry-delay 1 --connect-timeout 10 --max-time 120 \
      -o "${tmpdir}/${tarball}" "$url" \
      || die "Download failed (curl). Check network or GitHub access."
  else
    wget -T 30 -t 3 -O "${tmpdir}/${tarball}" "$url" \
      || die "Download failed (wget). Check network or GitHub access."
  fi

  log "Extracting..."
  tar -xzf "${tmpdir}/${tarball}" -C "$tmpdir" || die "Failed to extract tarball."

  # Find gost binary inside the extracted directory
  local bin_path=""
  bin_path="$(find "$tmpdir" -maxdepth 3 -type f -name gost -perm -111 2>/dev/null | head -n1 || true)"
  [[ -n "$bin_path" ]] || die "gost binary not found after extraction."

  install -m 0755 "$bin_path" /usr/local/bin/gost
  /usr/local/bin/gost -V >/dev/null 2>&1 || die "gost installed but failed to run."

  log "Installed gost to /usr/local/bin/gost"
}

check_ipv6_egress() {
  # Determine whether IPv6 egress is actually usable.
  # If usable, we will prefer IPv6 in resolver config; otherwise prefer IPv4 to avoid breaking connectivity.
  if curl -6 -fsS --max-time 6 https://ip.sb >/dev/null 2>&1; then
    IPV6_OK=1
  else
    IPV6_OK=0
  fi
}

write_gost_config() {
  local prefer
  mkdir -p /etc/nat-socks

  if [[ "${IPV6_OK}" -eq 1 ]]; then
    prefer="ipv6"
    log "IPv6 egress detected: will prefer IPv6 for outbound resolution."
  else
    prefer="ipv4"
    warn "No IPv6 egress detected: will prefer IPv4 for outbound resolution."
  fi

  cat > /etc/nat-socks/gost.yaml <<EOF
# Auto-generated by nat-socks.sh
# Two listeners (IPv4 + IPv6) to be robust across different bindv6only settings.
services:
  - name: nat-socks-v4
    addr: "0.0.0.0:${SOCKS_PORT}"
    handler:
      type: socks5
    listener:
      type: tcp
    resolver: resolver-0

  - name: nat-socks-v6
    addr: "[::]:${SOCKS_PORT}"
    handler:
      type: socks5
    listener:
      type: tcp
    resolver: resolver-0

resolvers:
  - name: resolver-0
    nameservers:
      - addr: "udp://1.1.1.1:53"
        prefer: ${prefer}
      - addr: "udp://8.8.8.8:53"
        prefer: ${prefer}
EOF

  log "Wrote config: /etc/nat-socks/gost.yaml"
}

write_systemd_service() {
  cat > /etc/systemd/system/nat-socks.service <<'EOF'
[Unit]
Description=nat-socks (SOCKS5 proxy via gost)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/bin/gost -C /etc/nat-socks/gost.yaml
Restart=on-failure
RestartSec=1
LimitNOFILE=1048576

# Hardening (safe defaults)
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=true

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable --now nat-socks >/dev/null
  log "systemd service installed & started: nat-socks"
}

get_public_ipv4() {
  # Must be public IPv4 as seen from outside (NAT machine local IP may be private).
  # Use multiple APIs as fallback.
  local ip=""
  ip="$(curl -4 -fsS --max-time 8 https://ipinfo.io/ip 2>/dev/null | tr -d ' \r\n' || true)"
  if [[ -z "$ip" ]]; then
    ip="$(curl -4 -fsS --max-time 8 https://api.ipify.org 2>/dev/null | tr -d ' \r\n' || true)"
  fi
  if [[ -z "$ip" ]]; then
    ip="$(curl -4 -fsS --max-time 8 https://ifconfig.co/ip 2>/dev/null | tr -d ' \r\n' || true)"
  fi

  [[ -n "$ip" ]] || die "Failed to get public IPv4 from external APIs."
  echo "$ip"
}

main() {
  need_root
  ask_port
  install_deps
  detect_arch
  check_ipv6_egress
  download_and_install_gost
  write_gost_config
  write_systemd_service

  # Final checks & output
  if ! systemctl is-active --quiet nat-socks; then
    systemctl --no-pager -l status nat-socks || true
    die "nat-socks service is not running."
  fi

  local pub4
  pub4="$(get_public_ipv4)"

  echo
  echo "${BOLD}========= Deployment Complete =========${RESET}"
  echo "Service: nat-socks (systemd)"
  echo "Listen : ${SOCKS_PORT} (no-auth)"
  echo

  # IPv6 status print
  if [[ "${IPV6_OK}" -eq 1 ]]; then
    echo "IPv6 出口状态：通"
  else
    echo "IPv6 出口状态：不通"
  fi

  # Highlight final connection string (public IPv4 + user port)
  echo
  echo "${GREEN}${BOLD}socks5://${pub4}:${SOCKS_PORT}${RESET}"
  echo
}

main "$@"
